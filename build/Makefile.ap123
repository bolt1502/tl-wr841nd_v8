ifndef BOARD_TYPE
export BOARD_TYPE=ap123
$(error "You have to define Board Type to use this Makefile")
endif

ifndef BUILD_TYPE
#export BUILD_TYPE=jffs2
export BUILD_TYPE=squashfs
endif

ifndef CONFIG_3G_TOOLS
export CONFIG_3G_TOOLS=y
endif

ifndef CONFIG_SNMP
export CONFIG_SNMP=n
endif

#
# Include the specific configuration files from the config.boardtype file
# here.  This removes the need to set environmental variables through a
# script before building
#

include scripts/$(BOARD_TYPE)/config.$(BOARD_TYPE)

#
# Put in safety checks here to ensure all required variables are defined in
# the configuration file
#

#ifndef TOOLPREFIX
#$(error "Must specify TOOLPREFIX value")
#endif

ifndef TOOLCHAIN
$(error "Must specify TOOLCHAIN value")
endif

ifndef TOOLARCH
$(error "Must specify TOOLARCH value")
endif

ifndef KERNEL
$(error "Must specify KERNEL value")
endif

ifndef KERNELVER
$(error "Must specify KERNELVER value")
endif

ifndef KERNELTARGET
$(error "Must specify KERNELTARGET value")
endif

ifndef KERNELARCH
$(error "Must specify KERNELARCH value")
endif

#~ifndef BUSYBOX
#~$(error "Must specify BUSYBOX value")
#~endif

ifndef TFTPPATH
export TFTPPATH=$(TOPDIR)/tftpboot/$(BOARD_TYPE)/
endif

# To enable library optimization (removing unused object code from
# shared libraries) set BUILD_LIBRARYOPT to 'y' else 'n'
BUILD_LIBRARYOPT := n

ifndef  BUILD_OPTIMIZED
export BUILD_OPTIMIZED=n
export STRIP=$(TOOLPREFIX)strip
endif

ifeq ($(BUILD_OPTIMIZED), y)
export OLDSTRIP=$(TOOLPREFIX)strip
export STRIP=$(TOOLPREFIX)sstrip
endif

ifndef COMPRESSED_UBOOT
export COMPRESSED_UBOOT=0
endif

ifndef ATH_CONFIG_NVRAM
export ATH_CONFIG_NVRAM=0
endif

ifndef ATH_SINGLE_CFG
export ATH_SINGLE_CFG=0
endif

ifndef INSTALL_BLACKLIST
export INSTALL_BLACKLIST="None"
endif

#~export NANDJFFS2FILE=$(BOARD_TYPE)$(BUILD_CONFIG)$(BUILD_EXT)-nand-jffs2
#~export YAFFS2FILE=$(BOARD_TYPE)$(BUILD_CONFIG)$(BUILD_EXT)-yaffs2
#~export JFFS2FILE=$(BOARD_TYPE)$(BUILD_CONFIG)$(BUILD_EXT)-jffs2
export IMAGEPATH=$(TOPDIR)/images/$(BOARD_TYPE)$(BUILD_CONFIG)$(BUILD_EXT)
#~export MODCPPATH=$(TOPDIR)/modules/$(BOARD_TYPE)$(BUILD_CONFIG)$(BUILD_EXT)

ifeq ($(BOOT_FROM_NAND),1)
export NAND=-nand
else
export NAND=
endif

export IMAGEPATH=$(TOPDIR)/images/$(BOARD_TYPE)$(BUILD_CONFIG)$(BUILD_EXT)$(NAND)

ifeq ($(strip $(BUILD_SQUASHFS)),1)
KERNEL_BUILD_CONFIG=_squashfs$(BUILD_CONFIG)
else
KERNEL_BUILD_CONFIG=$(BUILD_CONFIG)
endif

export INFOFILE=vmlinux$(BUILD_CONFIG)$(BUILD_EXT).info
export KTFILE=$(KERNELTARGET:.bin=$(BUILD_CONFIG)$(BUILD_EXT).bin)

ifneq ($(COMPRESSED_UBOOT),1)
export UBOOTFILE=u-boot$(BUILD_CONFIG)$(BUILD_EXT).bin
export UBOOT_BINARY=u-boot.bin
else
export UBOOTFILE=tuboot$(BUILD_CONFIG)$(BUILD_EXT).bin
export UBOOT_BINARY=tuboot.bin
endif
#
# Other environmental variables that are configured as per the configuration file
# specified above.  These contain all platform specific configuration items.
#

export TOPDIR=$(PWD)/..
export INSTALL_ROOT=$(TOPDIR)/rootfs.build.$(KERNELVER)
export INSTALL_ROOT_FOR_BOARD=$(TOPDIR)/rootfs.$(BOARD_TYPE)
export IMAGE_ROOT=$(TOPDIR)/rootfs-$(BOARD_TYPE)$(BUILD_CONFIG)$(BUILD_EXT).optbuild
temp_BOARD_TYPE = $(strip $(subst fus, , $(BOARD_TYPE)))

ifeq ($(strip $(ATH_CARR_DIR)),)
export KERNELPATH=$(TOPDIR)/$(BOARD_TYPE)/linux/kernels/$(KERNEL)
export MAKEARCH=$(MAKE) ARCH=$(KERNELARCH) CROSS_COMPILE=$(TOOLPREFIX)

export TOOLPATH=$(TOPDIR)/build/$(TOOLCHAIN)/$(TOOLARCH)/
export BOOTLOADERDIR=$(TOPDIR)/$(BOARD_TYPE)/boot/u-boot

export UBOOTDIR=$(TOPDIR)/$(BOARD_TYPE)/boot/u-boot
endif

# Save PATH for later use for compiling host-only tools etc.
#~export ORIGINAL_PATH:=$(PATH)
# Set PATH so we find target compiler when say "gcc", etc.
# as well as other tools we expect to find.
export PATH:=$(TOOLPATH)/bin:${PATH}

# madwifi
export HAL=$(TOPDIR)/$(BOARD_TYPE)/wlan/hal
export ATH_PHYERR=$(TOPDIR)/$(BOARD_TYPE)/wlan/madwifi/dfs
export ATH_RATE=$(TOPDIR)/$(BOARD_TYPE)/wlan/madwifi/ratectrl11n/
export MODULEPATH=$(INSTALL_ROOT)/lib/modules/$(KERNELVER)/net

#
# This is to allow the target file system size to be specified on the command
# line, if desired
#

#~ifndef TARGETFSSIZE
#~export TARGETFSSIZE=2621440
#~endif

# This allows the target flash erase block size to specified... it MUST be specified
# correctly or else e.g. jffs2 will break.
#~ifndef ERASEBLOCKSIZE
#~export ERASEBLOCKSIZE=0x10000
#~endif


#~ENTRY=`readelf -a vmlinux|grep "Entry"|cut -d":" -f 2`
#~LDADR=`readelf -a vmlinux|grep "\[ 1\]"|cut -d" " -f 26`

#~ifndef WIRELESSTOOLNAMES
#~$(warning "Should specify WIRELESSTOOLNAMES value")
## Note: WIRELESSTOOLNAMES can contain more files that we actually have...
## e.g. WIRELESSTOOLNAMES := athstats athstatsclr athdebug 80211stats 80211debug \
		athkey athampdutrc athcwm atrc pktlogconf pktlogdump radartool
#~WIRELESSTOOLNAMES :=
#~endif


#
# Common targts
#

#~ifndef AP_TYPE
# The INSTALL_ROOT is similar but not exactly what appears on the
# target filesystem; it is copied and converted into IMAGE_ROOT
# which is space-optimized.
#~rootfs_prep:	# this is prep of the INSTALL_ROOT, not the final fs directory
#~	@echo Begin rootfs_prep $(INSTALL_ROOT)
#~	rm -rf $(IMAGE_ROOT)
#~	rm -rf $(INSTALL_ROOT); mkdir $(INSTALL_ROOT)
#~	cp -R ../rootfs/common/* $(INSTALL_ROOT)
#~	cp -Rf ../rootfs/$(BOARD_TYPE)$(BUILD_CONFIG)/* $(INSTALL_ROOT)
#~	chmod 755 $(INSTALL_ROOT)/etc/rc.d/*
#~	chmod 755 $(INSTALL_ROOT)/etc/ath/*
#~	chmod 755 $(INSTALL_ROOT)/etc/ath/default/*
#~	@echo End rootfs_prep $(INSTALL_ROOT)

#~else
#
# For the retail AP designs, a new common area is used that contains the
# web interface and supporting files.  Also provides a common fusion based
# filesystem.
#

#~rootfs_prep:
#~	@echo Begin rootfs_prep $(INSTALL_ROOT)
#~	rm -rf $(IMAGE_ROOT)
#~	rm -rf $(INSTALL_ROOT); mkdir $(INSTALL_ROOT)
#~	cp -R ../rootfs/cgiCommon/* $(INSTALL_ROOT)
#~	cp -rf ../rootfs/cgiCommon/etc/ath.$(AP_TYPE)/* $(INSTALL_ROOT)/etc/ath
#~	rm -rf $(INSTALL_ROOT)/etc/ath.single $(INSTALL_ROOT)/etc/ath.dual
#~	cp -rf ../rootfs/cgiCommon/usr/www.$(AP_TYPE)/* $(INSTALL_ROOT)/usr/www
#~	rm -rf $(INSTALL_ROOT)/usr/www.single
#~	rm -rf $(INSTALL_ROOT)/usr/www.dual
#~	rm -rf $(INSTALL_ROOT)/etc/ath/hostapd0.7.0_conf
#~ifeq ($(KERNELVER),2.6.31)
#~	rm -rf $(INSTALL_ROOT)/lib/modules/2.6.15
#~endif
#~	if test -d "../rootfs/$(BOARD_TYPE)$(BUILD_CONFIG)" ; then  \
#~ 	    cp -Rf ../rootfs/$(BOARD_TYPE)$(BUILD_CONFIG)/* $(INSTALL_ROOT) ; \
#~        else \
#~ 	    cp -Rf ../rootfs/$(BOARD_TYPE)/* $(INSTALL_ROOT) ; \
#~	fi;
#~	chmod 755 $(INSTALL_ROOT)/etc/rc.d/*
#~	chmod 755 $(INSTALL_ROOT)/etc/ath/*
#~	@echo End rootfs_prep $(INSTALL_ROOT)
#~endif

#~ifeq ($(BUILD_UCLIBC_DEBUG),y)
#~BUILD_UCLIBC_DEBUG_FILTER = sed -e '/^DODEBUG=n/s/=n/=y/'
#~else
#~BUILD_UCLIBC_DEBUG_FILTER = "cat"
#~endif
#~toolchain_build: rootfs_prep
#~	echo "***** Checking toolchain status .."
#~	if [ "$(TOOLCHAIN)" = "gcc-4.3.3" -o "$(TOOLCHAIN)" = "gcc-4.5.1" ]; then \
#~	if test -f "$(TOOLCHAIN)/$(TOOLARCH)/.tcbuilt"; then echo "***** Toolchain already built.... ******"; \
#~	else \
#~	cd $(TOOLCHAIN) && \
#~	cp -f $(BOARD_TYPE).config .config && \
#~	rm -f toolchain/uClibc/uClibc.config && \
#~	cat toolchain/uClibc/$(BOARD_TYPE).config | $(BUILD_UCLIBC_DEBUG_FILTER) >toolchain/uClibc/uClibc.config && \
#~	$(MAKE) && touch $(TOOLARCH)/.tcbuilt; \
#~	fi;     \
#~	else \
#~	cd $(TOOLCHAIN) && \
#~	cp -f $(BOARD_TYPE).config .config && \
#~	rm -f toolchain/uClibc/uClibc.config && \
#~	cat toolchain/uClibc/$(BOARD_TYPE).config | $(BUILD_UCLIBC_DEBUG_FILTER) >toolchain/uClibc/uClibc.config && \
#~	$(MAKE); \
#~	fi;
#~	mkdir -p $(INSTALL_ROOT)/lib && \
#~	cd $(TOOLCHAIN) && $(MAKE) PREFIX=$(INSTALL_ROOT) install;
#~	# gdbserver to support debugging (if it has been created)
#~	if [ -f $(TOOLPATH)/root/usr/bin/gdbserver ] ; then \
#~	    mkdir -p $(INSTALL_ROOT)/usr/bin ; \
#~	    cp -f $(TOOLPATH)/root/usr/bin/gdbserver $(INSTALL_ROOT)/usr/bin/. ; \
#~	fi
#~	@echo End Making toolchain_build at `date`

#~toolchain_clean:
#~	@echo Cleaning toolchain ....
#~	cd $(TOOLCHAIN) &&  $(MAKE) clean && rm $(TOOLCHAIN)/$(TOOLARCH)/.tcbuilt

#~kernel_clean: 
#~	cd $(KERNELPATH) &&  $(MAKEARCH) mrproper 

#~kernel_info:
#~	cd $(KERNELPATH) && rm -f $(INFOFILE)
#~	cd $(KERNELPATH) && echo "entry:"${ENTRY} >> $(INFOFILE)
#~	cd $(KERNELPATH) && echo "link: 0x"${LDADR} >> $(INFOFILE)
#~	cp $(KERNELPATH)/$(INFOFILE) $(TFTPPATH)
#~	cp $(KERNELPATH)/$(INFOFILE) $(IMAGEPATH)


#
# If configured in kernel config, an initramfs trampoline is used.
# Should not hurt to build it anyway.
#
#~initramfs_prep:
#~	cd $(TOPDIR)/boot/initramfs && $(MAKE) clean && \
#~            $(MAKE) CC=$(TOOLPREFIX)gcc AR=$(TOOLPREFIX)ar LD=$(TOOLPREFIX)ld NM=$(TOOLPREFIX)nm all

#
# Use different kernel_build rules depending on the type of target
#

#~ifeq ($(KERNELTARGET), zImage)
#~kernel_build: image_prep initramfs_prep
#~	@echo " Making Kernel Build Version $(EXTRAVERSION)" at `date`
#~	exit
#~	cd $(KERNELPATH) && $(MAKEARCH) $(BOARD_TYPE)$(BUILD_CONFIG)_defconfig
#~	cd $(KERNELPATH) && $(MAKEARCH)
#~	cd $(KERNELPATH)/arch/$(KERNELARCH)/boot && \
#~	cp $(KERNELTARGET) $(TFTPPATH) && cp $(KERNELTARGET) $(IMAGEPATH)
#~else
kernel_build:
	@echo " Making Kernel Build Version $(EXTRAVERSION)" at `date`
	cd $(KERNELPATH) && $(MAKEARCH) $(BOARD_TYPE)$(KERNEL_BUILD_CONFIG)$(NAND)_defconfig
	cd $(KERNELPATH) && $(MAKEARCH) $(KERNELTARGET)
	cd $(KERNELPATH) && $(MAKEARCH) modules
	cd $(KERNELPATH)/arch/$(KERNELARCH)/boot && \
	cp $(KERNELTARGET) $(TFTPPATH)/$(KTFILE) && \
	cp $(KERNELTARGET) $(IMAGEPATH)/$(KTFILE) && \
	rm -rf $(KERNELTARGET).lzma && \
	$(TOPDIR)/util/lzma/bin/lzma --best --keep $(KERNELTARGET) && \
	cp $(KERNELTARGET).lzma $(TFTPPATH)/$(KTFILE).gz && \
	cp $(KERNELTARGET).lzma $(IMAGEPATH)/$(KTFILE).gz && \
	cp $(KERNELPATH)/vmlinux $(IMAGEPATH)/vmlinux
#~endif

export ENETDIR=$(TOPDIR)/$(BOARD_TYPE)/linux/drivers/ethernet/
enet_build: #kernel_build
	cd $(ENETDIR) && rm -f *.o *.ko *.mod.* && make -f Makefile.inc enet_config.h 
	cd $(ENETDIR) && rm -f *.o *.ko *.mod.*
	$(MAKEARCH) -C $(KERNELPATH) SUBDIRS=$(ENETDIR) modules
	test -d $(MODULEPATH) || mkdir -p $(MODULEPATH)
	cp $(ENETDIR)/athrs_gmac.ko $(KERNEL_MODULE_PATH)/ag7240_mod.ko

#~redboot_build:
#~	@echo Making redboot at `date`
#~	cd $(BOOTLOADERDIR) && make $(BOARD_TYPE)_rom
#~	cp $(BOOTLOADERDIR)/rom_bld/install/bin/redboot.rom $(IMAGEPATH)/redboot.$(BOARD_TYPE).rom
#~	cd $(BOOTLOADERDIR) && make $(BOARD_TYPE)_ram
#~	cp $(BOOTLOADERDIR)/ram_bld/install/bin/redboot.bin $(IMAGEPATH)/redboot.$(BOARD_TYPE).bin
#~	cp $(BOOTLOADERDIR)/ram_bld/install/bin/redboot.srec $(IMAGEPATH)/redboot.$(BOARD_TYPE).srec
#~	@echo End Making redboot at `date`

uboot:
	@echo Making uboot at `date`
	cd $(UBOOTDIR) && $(MAKEARCH) mrproper
ifneq ($(BOARD_TYPE), $(temp_BOARD_TYPE))
	echo ====Using $(temp_BOARD_TYPE) config for $(BOARD_TYPE) ===
	cd $(UBOOTDIR) && $(MAKEARCH) $(temp_BOARD_TYPE)_config
else
	cd $(UBOOTDIR) && $(MAKEARCH) $(BOARD_TYPE)_config
endif
	@echo ========= build dir: $(TOPDIR)/build ============
	cd $(UBOOTDIR) && $(MAKEARCH) all BUILD_DIR=$(TOPDIR)/build
	cp -f $(UBOOTDIR)/${UBOOT_BINARY} ${IMAGEPATH}/u-boot.bin
	cp -f $(UBOOTDIR)/${UBOOT_BINARY} $(TFTPPATH)/u-boot.bin
	@echo End Making uboot at `date`

#~busybox_clean:
#~	@echo Cleaning busybox
#~	cd ../apps/$(BUSYBOX) && make clean;

#~utelnetd:
#~	@echo make utelnetd
#~	cd ../apps/utelnetd-0.1.9 && make clean install

#~busybox_build:
#~	@echo Making busybox at `date`
#~	if test -f  "../apps/$(BUSYBOX)/defconfig-$(BOARD_TYPE)$(BUILD_CONFIG)$(BUILD_DEBUG)"; then \
#~	cd ../apps/$(BUSYBOX) && make clean && \
#~	cp -f defconfig-$(BOARD_TYPE)$(BUILD_CONFIG)$(BUILD_DEBUG) .config && \
#~	    $(MAKE) && $(MAKE) PREFIX=$(INSTALL_ROOT) install; \
#~	else \
#~	    cd ../apps/$(BUSYBOX) && make clean && \
#~	    cp -f  defconfig-$(BOARD_TYPE)$(BUILD_DEBUG) .config && \
#~	    $(MAKE) && $(MAKE) PREFIX=$(INSTALL_ROOT) install; \
#~	fi;
#~	@echo End Making busybox at `date`

# wastemem is a very small but very useful development tool 
# If you really don't want it in the build, 
# add it to the optimzation blacklist file!
#~wastemem_build:
#~	@echo Making wastemem
#~	cd ../apps/wastemem && make clean && make install
#~wastemem_clean:
#~	cd ../apps/wastemem && make clean
# Ugly hack so you get wastemem if you get busybox...
## use /proc/sys/vm/min_free_kbytes instead:   busybox_build: wastemem_build

#~spectral_app_clean:
#~	@echo Cleaning spectral
#~	cd ../apps/spectral && make clean;

#~spectral_app_build: spectral_app_clean   
#~	@echo making Spectral tools
#~	cd ../apps/spectral && $(MAKE) -f Makefile
#~	cp ../apps/spectral/spectraldaemon $(INSTALL_ROOT)/sbin/

#~diag_build:
#~	@echo diag_build
#~	cd $(HAL)/diag && make 


#~sar:
#~	@echo making sar
#~	cd ../apps/sysstat-6.0.1/ && rm -f sysstat.cron.daily && rm -f sysstat.cron.hourly && $(MAKE) CC=$(TOOLPREFIX)gcc 
#~	cd ../apps/sysstat-6.0.1/ && cp sar $(INSTALL_ROOT)/usr/bin/
#~	cd ../apps/sysstat-6.0.1/ && cp sadc $(INSTALL_ROOT)/usr/bin/

#~flash_mac:
#~	@echo making flash_mac 
#~	cd ../apps/flash_mac/ && make CC=$(TOOLPREFIX)gcc STRIP=$(TOOLPREFIX)strip && cp read_cfg $(INSTALL_ROOT)/usr/bin/
	

# Optional library optimization (upon IMAGE_ROOT), enable with 
#            BUILD_LIBRARYOPT := y
#
# Library optimization removes unused code from shared libraries.
# Read libraryopt/README-libraryopt.txt for details.
#~LIBOPTTEMP=$(TOPDIR)/build/libopt.temp
#
# Second stage of library optimization is done on the copy of $(INSTALL_ROOT)
# which is $(IMAGE_ROOT) .
# NOTE: $(INSTALL_ROOT) executables must NOT be stripped! 
# that would interfere with debugging and perhaps with library optimization.
#
# The main problems with using library optimizer are:
# -- The build procedure is fragile and can break with any tools
#    or c library upgrade.
# -- Executables not visible at build time but added later may fail
#    unless they have been staticly linked.
#
#~ifeq ($(BUILD_LIBRARYOPT),y)

#~LIBOPTINFOSRC=$(TOPDIR)/build/libraryopt/optinfo
#~LIBOPTSCRIPTSRC=$(TOPDIR)/build/libraryopt/libraryopt-1.0.1

# libopt requires target/usr/lib/optinfo below LIBOPTTEMP
#~LIBOPTTEMPINFO=$(LIBOPTTEMP)/target/usr/lib/optinfo
#~LIBOPTTOOLSRC=$(TOPDIR)/build/$(TOOLCHAIN)/$(TOOLARCH)
#~LIBOPTTOOLSRC2=$(TOPDIR)/build/$(TOOLCHAIN)/toolchain_$(TOOLARCH)/uClibc

#~endif

# The IMAGE_ROOT is created from the INSTALL_ROOT by making
# a copy and optimizing the amount of file system space consumed
# through a variety of methods.
# This will be the file system actually installed on target.
# NOTE! It is important that $(INSTALLS) contains a list of all make targets to
# be done in order that $(INSTALL_ROOT) is complete !!!!!!!!!!!!!
#~image_root: $(INSTALLS) 
#~	@echo Making image root $(IMAGE_ROOT) at `date`
#~	rm -rf $(IMAGE_ROOT)
#~	rm -rf $(LIBOPTTEMP)
#~	cp -a $(INSTALL_ROOT) $(IMAGE_ROOT)
#~	# Remove unwanted files
#~	@for file in "$(INSTALL_BLACKLIST)" ; \
#~		do echo "Removing $(IMAGE_ROOT)/$$file"; rm -rf $(IMAGE_ROOT)/$$file ;done 
#~	rm -rf $(IMAGE_ROOT)/include
#~	rm -rf $(IMAGE_ROOT)/man
#~	rm -rf $(IMAGE_ROOT)/usr/man
#~	rm -rf $(IMAGE_ROOT)/lib/*.a
#~	rm -rf $(IMAGE_ROOT)/usr/lib/*.a
#~	# could be:  rm -f $(IMAGE_ROOT)/usr/bin/gdbserver
#~	# Apply library optimizer (optional)
#~ifeq ($(BUILD_LIBRARYOPT),y)
#~	rm -rf $(LIBOPTTEMP)
#~	echo Preparing for library optimizer at `date`
#~	mkdir -p $(LIBOPTTEMP)
#~	# libopt expects tools in bin, all with same prefix,
#~	# including libopt and libindex scripts themselves.
#~	mkdir -p $(LIBOPTTEMP)/bin
#~	ln -s $(LIBOPTTOOLSRC)/bin/* $(LIBOPTTEMP)/bin/.
#~	ln -s $(LIBOPTSCRIPTSRC)/src/libopt $(LIBOPTTEMP)/bin/$(TOOLPREFIX)libopt
#~	ln -s $(LIBOPTSCRIPTSRC)/src/libindex $(LIBOPTTEMP)/bin/$(TOOLPREFIX)libindex
#~	# and for our own convenience we build a lib directory with all
#~	# of the various files we will need
#~	mkdir -p $(LIBOPTTEMP)/lib
#~	ln -s $(LIBOPTTOOLSRC)/lib/* $(LIBOPTTEMP)/lib/.
#~	# libgcc.a is hard to find. E.g. it can be found at:
#~	#  build/gcc-3.4.4-2.16.1/build_mips/lib/gcc/mips-linux-uclibc/3.4.4/libgcc.a
#~	ln -s $(LIBOPTTOOLSRC)/lib/gcc/*/*/libgcc.a $(LIBOPTTEMP)/lib/.
#~	ln -s $(LIBOPTTOOLSRC2)/*/*_so.a $(LIBOPTTEMP)/lib/.
#~	ln -s $(LIBOPTTOOLSRC2)/*/*/*_so.a $(LIBOPTTEMP)/lib/.
#~	ln -s $(LIBOPTTOOLSRC2)/lib/interp.os $(LIBOPTTEMP)/lib/.
#~	mkdir -p $(LIBOPTTEMPINFO)
#~	set -e ; \
#~        app_sofiles=`find $(INSTALL_ROOT) -name '*.so' -print` ; \
#~	for app_sofile in $$app_sofiles ; do \
#~          sobject=`basename $$app_sofile` ; \
#~          soname=`basename $$sobject .so` ; \
#~          aobject=`dirname $$app_sofile`/$$soname.a ; \
#~	  if [ -L $$app_sofile ] ; then true; else \
#~	    echo Looking at $$app_sofile ... ; \
#~	    if [ -d $(LIBOPTINFOSRC)/$$sobject ] ; then \
#~	      echo Creating libopt temp info for special shared object file $$sobject ; \
#~	      cp -a $(LIBOPTINFOSRC)/$$sobject $(LIBOPTTEMPINFO)/. ; \
#~	      cp -a $$app_sofile $(LIBOPTTEMPINFO)/$$sobject/.;  \
#~              ln -s $(LIBOPTTEMP)/lib $(LIBOPTTEMPINFO)/$$sobject/required; \
#~	      (cd $(LIBOPTTEMPINFO)/$$sobject && ./prebuild $(LIBOPTTEMP)/bin/$(TOOLPREFIX)libindex $(LIBOPTTOOLSRC)/lib) ; \
#~	    elif [ -f $$aobject ] ; then \
#~	      echo Creating libopt temp info for application shared object file $$sobject ; \
#~	      cp -a $(LIBOPTINFOSRC)/generic $(LIBOPTTEMPINFO)/$$sobject ; \
#~	      cp -a $$app_sofile $(LIBOPTTEMPINFO)/$$sobject/.;  \
#~              ln -s $(LIBOPTTEMP)/lib $(LIBOPTTEMPINFO)/$$sobject/required; \
#~              mkdir $(LIBOPTTEMPINFO)/$$sobject/apps; \
#~              for other_so_file in $$app_sofiles ; do \
#~                other_so=`basename $$other_so_file`  ;   \
#~                if [ $$other_so != $$sobject ] ; then \
#~                  ln -s $$other_so_file $(LIBOPTTEMPINFO)/$$sobject/apps/. ; \
#~                fi ; \
#~              done ; \
#~              ln -s $$aobject $(LIBOPTTEMPINFO)/$$sobject/. ; \
#~	      (cd $(LIBOPTTEMPINFO)/$$sobject && ./prebuild $(LIBOPTTEMP)/bin/$(TOOLPREFIX)libindex $$sobject) ; \
#~	      (cd $(LIBOPTTEMPINFO)/$$sobject && $(LIBOPTTEMP)/bin/$(TOOLPREFIX)objdump -p $$sobject | awk '/^ *NEEDED/{print $$2}' >needed ) ; \
#~            else echo Skipping $$sobject ; \
#~	    fi; \
#~	  fi; \
#~        done
#~	echo Running library optimizer at `date`
#~	$(LIBOPTTEMP)/bin/$(TOOLPREFIX)libopt $(IMAGE_ROOT)
#~	echo Done with library optimizer at `date`
#~endif  # BUILD_LIBRARYOPT
#~	# Now we can strip executables (also strip libraries if needed)
#~	cd $(IMAGE_ROOT)/lib && $(STRIP) *.so
#~	# find $(IMAGE_ROOT)/sbin -type f -perm -u+x -exec $(STRIP) '{}' ';'
#~	# find $(IMAGE_ROOT)/bin -type f -perm -u+x -exec $(STRIP) '{}' ';'
#~	# find $(IMAGE_ROOT)/usr/bin -type f -perm -u+x -exec $(STRIP) '{}' ';'
#~	find $(IMAGE_ROOT) -type f -perm -u+x -exec $(STRIP) '{}' ';'
#~ifeq ($(BUILD_OPTIMIZED),y)
#~	# Refer to kernel/module.c:load_module() in linux sources
#~	# for the sections that can be removed without affecting insmod
#~	find $(IMAGE_ROOT)/lib/modules/$(KERNELVER) -name "*.ko" -type f \
#~		-exec $(OLDSTRIP) \
#~			--strip-unneeded \
#~			--remove-section=__kcrctab \
#~			--remove-section=__kcrctab_gpl \
#~			--remove-section=__param \
#~			--remove-section=__ex_table \
#~			--remove-section=__obsparm \
#~			--remove-section=__versions \
#~			--remove-section=.pdr \
#~			--remove-section=.mdebug.abi32 \
#~			--remove-section=.comment \
#~			--remove-section=__ksymtab_gpl_future \
#~			--remove-section=__kcrctab_gpl_future \
#~			--remove-section=__ksymtab_unused \
#~			--remove-section=__kcrctab_unused \
#~			--remove-section=__ksymtab_unused_gpl \
#~			--remove-section=__kcrctab_unused_gpl \
#~			--remove-section=.ctors \
#~			--remove-section=__markers \
#~			--remove-section=__tracepoints \
#~			--remove-section=_ftrace_events \
#~			--remove-section=__mcount_loc \
#~			-x '{}' ';'
#~endif
#~	# Some additional space savings is gained by using tar/gzip compression
#~	# on wireless tools, which get unpacked by rcS script into /tmp
#~	# ram disk... perhaps a waste of ram however.
#~	# The amount of flash space thus saved is not large.
#~	echo Warnings from tar about missing files are normal for some targets.
#~	if [ -n "$(WIRELESSTOOLNAMES)" -a "$(BUILD_TYPE)" = jffs2 ] ; then cd $(IMAGE_ROOT)/sbin && \
#~	    tar --ignore-failed-read -czf debug.tgz $(WIRELESSTOOLNAMES) && \
#~	    rm -f $(WIRELESSTOOLNAMES) && \
#~	    for tool in $(WIRELESSTOOLNAMES) ; do ln -s /tmp/tools/$$tool .; done; \
#~	    fi
#~	@echo DONE BUILDING image_root at `date`

#~ram_build: image_root
#~	@echo Making ramfs at `date`
#~	cd util && \
#~        genext2fs -b 8192 -i 512 -D ../scripts/$(BOARD_TYPE)/dev.txt -d $(IMAGE_ROOT) $(BOARD_TYPE)-ramdisk
#~	cd util && gzip --best -f $(BOARD_TYPE)-ramdisk
#~	cd util && cp $(BOARD_TYPE)-ramdisk.gz $(TFTPPATH)
#~	cd util && cp $(BOARD_TYPE)-ramdisk.gz $(IMAGEPATH)
#~	@echo Done Making ramfs at `date`

#~uimage:	kernel_build
#~	@echo Making uImage at `date`
#~	cd util && mkuImage.sh $(UBOOTDIR)/tools $(KERNELPATH) "$(BUILD_CONFIG)$(BUILD_EXT)"
#~	@echo Done Making uImage at `date`

#~jffs2_build: image_root
#~	@echo Making jffs2 at `date`
#~	cd $(IMAGEPATH) && \
#~	$(TOPDIR)/build/util/mkfs.jffs2 --root=$(IMAGE_ROOT) --eraseblock=$(ERASEBLOCKSIZE) -b -D $(TOPDIR)/build/scripts/$(BOARD_TYPE)/dev.txt --squash -o $(JFFS2FILE) --pad=$(TARGETFSSIZE)
#~	cp $(IMAGEPATH)/$(JFFS2FILE) $(TFTPPATH)
#~	@echo Done Making jffs2 at `date`

# NOTE: initramfs_build does NOT necessarily build the primary initramfs image,
#       which may be done by the kernel... instead, it may build a secondary
#       initramfs image, which is loaded from flash by inittrampoline.
#       It is possible however to use this generated as the primary
#       initramfs image, but in this case you will need to insure that
#       the kernel build depends upon initramfs_build, and have an appropriate
#       kernel configuration of CONFIG_INITRAMFS_SOURCE.
#~initramfs_build : initramfs_prep image_root
#~	rm -f $(IMAGEPATH)/$(BOARD_TYPE)$(BUILD_CONFIG)$(BUILD_EXT).cpio*
#~	$(TOPDIR)/boot/initramfs/geninitramfs -device_table $(TOPDIR)/build/scripts/$(BOARD_TYPE)/dev.txt -copy $(IMAGE_ROOT) /  >$(IMAGEPATH)/$(BOARD_TYPE)$(BUILD_CONFIG)$(BUILD_EXT).cpio
#~	lzma $(IMAGEPATH)/$(BOARD_TYPE)$(BUILD_CONFIG)$(BUILD_EXT).cpio

# An empty jffs2 filesystem may be used in conjunction with squashfs or initramfs to hold
# 	non-volatile storage.
# 	NOTE: We need an empty directory for mkfs.jffs2 to copy, so we temporarily create one.
#~empty_jffs2_build:
#~	cd $(IMAGEPATH) && rm -rf empty empty-jffs2 && mkdir empty && \
#~	$(TOPDIR)/build/util/mkfs.jffs2 --root=$(IMAGEPATH)/empty --eraseblock=$(ERASEBLOCKSIZE) -b --squash -o empty-jffs2 --pad=$(TARGETFSSIZE) && \
#~	rm -rf empty
#~	cp $(IMAGEPATH)/empty-jffs2 $(TFTPPATH)

#~clean: kernel_clean busybox_clean
#~	@echo CAUTION THIS WILL NOT CLEAN EVERYTHING
#~	rm -rf $(TOOLPATH)
#~	rm -rf $(TOPDIR)/build/$(TOOLCHAIN)/toolchain_$(TOOLARCH)/
#~	rm -rf $(TOPDIR)/images
#~	rm -rf $(IMAGE_ROOT)
#~	rm -rf $(INSTALL_ROOT)
#~	rm -rf $(LIBOPTTEMP)
#~	@echo CAUTION THIS WILL NOT CLEAN EVERYTHING

tpclean:
	@echo clean build environment
	rm -rf $(TFTPPATH)
	rm -rf $(IMAGEPATH)
	rm -rf $(INSTALL_ROOT_FOR_BOARD)
	rm -rf $(INSTALL_ROOT)
	find $(KERNELPATH) -name "*.o" | xargs rm -rf
	find $(TOPDIR)/apps -name "*.o" | xargs rm -rf

####################################### wireless ##########################################
hal_build: 
	@echo making hal
	if test -n "$(MADWIFITARGET)"; then \
	cd $(HAL)/linux && make TARGET=$(MADWIFITARGET) clean &&  \
	make TARGET=$(MADWIFITARGET) && make TARGET=$(MADWIFITARGET) release; \
	fi

ifeq ($(BUILD_WPA2),y)  ####################################
# apps/wpa2 provides a second generation (as compared with apps/wpa)
#       of authentication (including WPS) programs:
#       hostapd, wpa_supplicant, etc.
# 	It installs via $(INSTALL_ROOT).
# 	It depends only on header files from the driver, and linux driver
# 	(madwifi) header files specified by $(MADWIFIPATH)

wpa2: wpa2_clean #rootfs_prep
	@echo Making wpa2 at `date`
	cd ../$(BOARD_TYPE)/apps/wpa2 && $(MAKE) 	\
		CC=$(TOOLPREFIX)gcc AR=$(TOOLPREFIX)ar LD=$(TOOLPREFIX)ld
	cp $(TOPDIR)/$(BOARD_TYPE)/apps/wpa2/hostapd/hostapd $(WIRELESSPACKAGEPATH)
	cp $(TOPDIR)/$(BOARD_TYPE)/apps/wpa2/common/libwpa_common.so $(WIRELESSPACKAGEPATH)
	cp $(TOPDIR)/$(BOARD_TYPE)/apps/wpa2/common/libwpa_ctrl.so $(WIRELESSPACKAGEPATH)
	cp $(TOPDIR)/$(BOARD_TYPE)/apps/wpa2/wpa_supplicant/wpa_supplicant $(WIRELESSPACKAGEPATH)
	@echo End Making wpa2 at `date`

wpa2_clean:
	cd ../$(BOARD_TYPE)/apps/wpa2 && $(MAKE) clean
clean: wpa2_clean

else  ####(BUILD_WPA2),y####
# apps/wpa provides older generation of hostapd, wpa_supplicant, etc.

#~hostapd: openssl
#~	if ( test -e ../apps/wpa/hostapd-0.4.8 ) then \
#~	cd ../apps/wpa/hostapd-0.4.8; cp -f defconfig .config; make clean; make; \
#~	make PREFIX=$(INSTALL_ROOT)/sbin CONFIG_PATH=$(INSTALL_ROOT)/etc/ath DEFAULT_CFG=$(INSTALL_ROOT)/etc/ath/default install; \
#~	fi

#~openssl:
#~	if (test -e ../apps/wpa/wsc/lib/openssl-0.9.8a ) then \
#~	chmod -R 755 ../apps/wpa/wsc/lib/openssl-0.9.8a; \
#~	cd ../apps/wpa/wsc/lib/openssl-0.9.8a; make clean; make; fi

#~wsc: hostapd
#~	if (test -e ../apps/wpa/wsc/src/linux ) then \
#~	chmod -R 755 ../apps/wpa/wsc/src/lunux; \
#~	cd ../apps/wpa/wsc/src/linux; make clean; \
#~	make PREFIX=$(INSTALL_ROOT)/sbin CONFIG_PATH=$(INSTALL_ROOT)/etc/ath DEFAULT_CFG=$(INSTALL_ROOT)/etc/ath/default install; \
#~	fi

#~wpa_supplicant:
#~	if (test -e ../apps/wpa/wpa_supplicant-0.5.5 ) then \
#~	cd ../apps/wpa/wpa_supplicant-0.5.5; cp -f defconfig .config; make clean; \
#~	make; make PREFIX=$(INSTALL_ROOT)/sbin install; \
#~	fi

#~wps_enrollee:    
#~	if (test -e ../apps/wpa/wps_enrollee) then \
#~	cd ../apps/wpa/wps_enrollee; make clean; make; \
#~	make PREFIX=$(INSTALL_ROOT)/sbin install; \
#~	fi
endif ####(BUILD_WPA2),y####

export WIRELESSPACKAGEPATH=$(IMAGEPATH)/wireless/

wireless_prep:
	test -d $(WIRELESSPACKAGEPATH) || mkdir -p $(WIRELESSPACKAGEPATH)
	
wireless:wireless_prep madwifi_build wpa2

hal_build_main:
	@echo making Mainline hal
	if test -n "$(TARGETARCH)"; then \
	cd $(HAL)/linux && make TARGET=$(TARGETARCH) clean &&  \
	make TARGET=$(TARGETARCH) && make TARGET=$(TARGETARCH) release; \
	fi
	
wireless_tools:
	@echo making wireless_tools 
	if test -n "$(WIRELESSTOOLS)"; then \
	cd $(TOPDIR)/$(BOARD_TYPE)/apps/$(WIRELESSTOOLS) &&  make clean && make; \
	mkdir -p $(INSTALL_ROOT)/sbin; \
	cp -f $(WIRELESSTOOLSLIB) $(WIRELESSPACKAGEPATH); \
	cp -f iwpriv $(WIRELESSPACKAGEPATH); \
	cp -f iwconfig $(WIRELESSPACKAGEPATH); \
	cp -f iwlist $(WIRELESSPACKAGEPATH); \
	cd $(TOPDIR)/$(BOARD_TYPE)/wlan/os/linux/tools && make clean; \
	make BUILD_STATIC=$(BUILD_STATIC) wlanconfig; \
	cp -f wlanconfig $(WIRELESSPACKAGEPATH) && \
	for file in $(WIRELESSTOOLNAMES) ; do \
		if [ -f $$file ] ; then \
			cp -f $$file $(INSTALL_ROOT)/sbin/.; fi; done; \
	fi

ath_tools_build:
	@echo makeing ath tools;\
	cd $(TOPDIR)/$(BOARD_TYPE)/wlan/os/linux/tools;\
	make ath_tools_clean && make ath_tools;\
	cp -f pktlogconf pktlogdump $(WIRELESSPACKAGEPATH)
	

madwifi_build: hal_build_main wireless_tools ath_tools_build
	@echo making umac mainline
	cd $(TOPDIR)/$(BOARD_TYPE)/wlan/os/linux && \
	$(MAKEARCH) TARGET=$(TARGETARCH) clean \
	&& $(MAKEARCH) TARGET=$(TARGETARCH) && \
	cp $(TOPDIR)/$(BOARD_TYPE)/wlan/umac/*.ko $(WIRELESSPACKAGEPATH)
	cp $(TOPDIR)/$(BOARD_TYPE)/wlan/asf/*.ko $(WIRELESSPACKAGEPATH)
	cp $(TOPDIR)/$(BOARD_TYPE)/wlan/adf/*.ko $(WIRELESSPACKAGEPATH)
	cp $(TOPDIR)/$(BOARD_TYPE)/wlan/lmac/ratectrl/*.ko $(WIRELESSPACKAGEPATH)
#	cp $(TOPDIR)/$(BOARD_TYPE)/wlan/lmac/ath_pktlog/*.ko $(WIRELESSPACKAGEPATH)
	cp $(TOPDIR)/$(BOARD_TYPE)/wlan/lmac/ath_dev/*.ko $(WIRELESSPACKAGEPATH)
	$(TOOLPREFIX)strip -S $(TOPDIR)/$(BOARD_TYPE)/wlan/os/linux/ath_hal/*.ko
	cp $(TOPDIR)/$(BOARD_TYPE)/wlan/os/linux/ath_hal/*.ko $(WIRELESSPACKAGEPATH)
#	$(MAKEARCH) DESTDIR=$(INSTALLROOT) TARGET=$(TARGETARCH) install
#	$(MAKE) $(BUILD_TYPE)_build

wireless_install:
	cd $(WIRELESSPACKAGEPATH) && \
	cp -f $(WIRELESSTOOLSLIB) $(INSTALL_ROOT_FOR_BOARD)/lib; \
	ln -sf $(WIRELESSTOOLSLIB) $(INSTALL_ROOT_FOR_BOARD)/lib/libiw.so; \
	cp -f *.so $(INSTALL_ROOT_FOR_BOARD)/lib; \
	cp -f iwpriv $(INSTALL_ROOT_FOR_BOARD)/sbin; \
	cp -f iwconfig $(INSTALL_ROOT_FOR_BOARD)/sbin; \
	cp -f iwlist $(INSTALL_ROOT_FOR_BOARD)/sbin; \
	cp -f wlanconfig $(INSTALL_ROOT_FOR_BOARD)/sbin; \
	cp -f hostapd $(INSTALL_ROOT_FOR_BOARD)/sbin; \
	cp -f wpa_supplicant $(INSTALL_ROOT_FOR_BOARD)/sbin; \
	cp -f *.ko $(INSTALL_ROOT_FOR_BOARD)/lib/modules/$(KERNELVER)/net

art:
	cd $(TOPDIR)/$(BOARD_TYPE)/apps/art2/src/driver/linux && make -f makefile.artmod clean wasp
	cd $(TOPDIR)/$(BOARD_TYPE)/apps/art2/src/art && make -f makefile.nart clean all
	
#
# AP123 need usb driver, we only make usb class driver modules 
# because usbcore and usb_echi are already compiled with kernel
#
usb_serial:
	$(MAKEARCH) -C $(KERNELPATH) SUBDIRS=drivers/usb/serial modules	
	cp $(KERNELPATH)/drivers/usb/serial/usbserial.ko $(KERNEL_MODULE_PATH)
	cp $(KERNELPATH)/drivers/usb/serial/option.ko $(KERNEL_MODULE_PATH)
	cp $(KERNELPATH)/drivers/usb/serial/qcserial.ko $(KERNEL_MODULE_PATH)
	cp $(KERNELPATH)/drivers/usb/class/cdc-acm.ko $(KERNEL_MODULE_PATH)

usb_storage:
	cp $(KERNELPATH)/drivers/scsi/scsi_mod.ko $(KERNEL_MODULE_PATH)
	cp $(KERNELPATH)/drivers/scsi/sg.ko $(KERNEL_MODULE_PATH)
	cp $(KERNELPATH)/drivers/scsi/sd_mod.ko $(KERNEL_MODULE_PATH)
	cp $(KERNELPATH)/drivers/scsi/scsi_wait_scan.ko $(KERNEL_MODULE_PATH)
	cp $(KERNELPATH)/drivers/usb/storage/usb-storage.ko $(KERNEL_MODULE_PATH)
	cp $(KERNELPATH)/fs/fat/fat.ko $(KERNEL_MODULE_PATH)
	cp $(KERNELPATH)/fs/fat/vfat.ko $(KERNEL_MODULE_PATH)
	cp $(KERNELPATH)/fs/fat/msdos.ko $(KERNEL_MODULE_PATH)

####################################### END wireless #######################################

#
# 3G tools build for apps build
#
export 3G_TOOLS_PATH = $(TOPDIR)/apps/3g_tools
export 3G_PACKAGE_PATH = $(IMAGEPATH)/3g

include $(3G_TOOLS_PATH)/Makefile
	
3g_prep:
	test -d $(3G_PACKAGE_PATH) || mkdir -p $(3G_PACKAGE_PATH)

3g_tools:  3g_prep
	-rm -rf $(3G_PACKAGE_PATH)/*
	cd $(3G_TOOLS_PATH) && \
	$(MAKE) CC=$(TOOLPREFIX)gcc AR=$(TOOLPREFIX)ar LD=$(TOOLPREFIX)ld 

3g_tools_install: 3g_prep
	cd $(3G_PACKAGE_PATH) && \
	cp -f chat $(INSTALL_ROOT_FOR_BOARD)/usr/sbin && \
	cp -f libusb-0.1.so.4.4.4 $(INSTALL_ROOT_FOR_BOARD)/lib && \
	ln -sf libusb-0.1.so.4.4.4 $(INSTALL_ROOT_FOR_BOARD)/lib/libusb-0.1.so.4 && \
	ln -sf libusb-0.1.so.4.4.4 $(INSTALL_ROOT_FOR_BOARD)/lib/libusb.so && \
	cp -f handle_card $(INSTALL_ROOT_FOR_BOARD)/usr/sbin/ && \
	cp -f usr/sbin/usb_modeswitch $(INSTALL_ROOT_FOR_BOARD)/usr/sbin/ && \
	cp -f modem_scan $(INSTALL_ROOT_FOR_BOARD)/usr/sbin/ && \
	cp -f mode_switch.conf.bin $(INSTALL_ROOT_FOR_BOARD)/etc/ && \
	cp -f hotplug $(INSTALL_ROOT_FOR_BOARD)/sbin && \
	cp -rf etc/ppp $(INSTALL_ROOT_FOR_BOARD)/etc
#	cp -rf etc/usb_modeswitch.d $(INSTALL_ROOT_FOR_BOARD)/etc/usb_modeswitch.d
	if grep 'mount -t usbfs none /proc/bus/usb' $(INSTALL_ROOT_FOR_BOARD)/etc/rc.d/rcS > /dev/null 2>&1 ; then \
	echo "rcS already have mount -t usbfs none /proc/bus/usb"  ;\
	else \
	sed 's/mount -t ramfs -n none \/var/mount -t ramfs -n none \/var\nmount -t usbfs none \/proc\/bus\/usb/' $(INSTALL_ROOT_FOR_BOARD)/etc/rc.d/rcS > $(INSTALL_ROOT_FOR_BOARD)/etc/rc.d/rcS.tmp && \
	mv -f $(INSTALL_ROOT_FOR_BOARD)/etc/rc.d/rcS.tmp $(INSTALL_ROOT_FOR_BOARD)/etc/rc.d/rcS && \
	chmod 755 $(INSTALL_ROOT_FOR_BOARD)/etc/rc.d/rcS ; \
	fi

#routers

wr841nv8_fs_en:
	make apxxfus_fs_prep enet=ag7240 lang=en oem_dir=WR841N8.0 conf_file=wr841nv8_en.conf CONFIG_3G_TOOLS=n
	make mk_squashfs_build fs_size=0x2C0000

wr843ndv1_fs_en:
	make apxxfus_fs_prep enet=ag7240 lang=en oem_dir=WR843ND1.0 conf_file=wr843ndv1_en.conf
	make mk_squashfs_build fs_size=0x2C0000

rn501dv4_fs_en:
	make apxxfus_fs_prep enet=ag7240 lang=en oem_dir=PW-RN501D4.0 conf_file=pw-rn501dv4_en.conf CONFIG_3G_TOOLS=n
	make mk_squashfs_build fs_size=0x2C0000
	
wr841nv8_image_en: wr841nv8_fs_en
	make image_build prefix=wr841nv8_en

wr843ndv1_image_en: wr843ndv1_fs_en
	make image_build prefix=wr843ndv1_en

rn501dv4_image_en: rn501dv4_fs_en
	make image_build prefix=rn501dv4_en
	
wr841nv8_en: httpd_build wr841nv8_image_en
wr843ndv1_en: httpd_build wr843ndv1_image_en
rn501dv4_en:httpd_build rn501dv4_image_en

all_images_r: wr841nv8_image_en rn501dv4_image_en wr843ndv1_image_en
	mkdir -p $(IMAGEPATH)/$(shell date +%y%m%d)
	mv $(IMAGEPATH)/*$(shell date +%y%m%d)*.bin $(IMAGEPATH)/$(shell date +%y%m%d)

#3g routers

mr3420v2_fs_en:
	make apxxfus_fs_prep enet=ag7240 lang=en oem_dir=MR3420_2.0 conf_file=mr3420v2_en.conf
	make mk_squashfs_build fs_size=0x2C0000

wr843nv1_fs_cn:
	make apxxfus_fs_prep enet=ag7240 lang=cn oem_dir=WR843N_1.0 conf_file=wr843nv1_cn.conf
	make mk_squashfs_build fs_size=0x2C0000
	
mr3420v2_image_en: mr3420v2_fs_en
	make image_build prefix=mr3420v2_en

wr843nv1_image_cn: wr843nv1_fs_cn
	make image_build prefix=wr843nv1_cn

mr3420v2_en: httpd_build mr3420v2_image_en

wr843nv1_cn: httpd_build wr843nv1_image_cn

all_images_3g: mr3420v2_image_en wr843nv1_image_cn
	mkdir -p $(IMAGEPATH)/$(shell date +%y%m%d)
	mv $(IMAGEPATH)/*$(shell date +%y%m%d)*.bin $(IMAGEPATH)/$(shell date +%y%m%d)


#ap products

wa801nv2_fs_en:
	make apxxfus_fs_prep enet=ag7240 lang=en oem_dir=WA801N2.0 conf_file=wa801nv2_en.conf CONFIG_3G_TOOLS=n CONFIG_SNMP=y
	$(TOPDIR)/util/rmjunkfiles
	make mk_squashfs_build fs_size=0x2C0000

wa801nv2_image_en: wa801nv2_fs_en
	make image_build prefix=wa801nv2_en

wa801nv2_en: httpd_build wa801nv2_image_en
